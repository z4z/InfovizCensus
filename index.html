<!DOCTYPE html>
<meta charset="utf-8">
<style>

.tract {
  fill: #ebebeb;
  stroke: black;
  stroke-width: .1;
}

.tract:hover {
  fill: blue;
}

</style>
<body>
<script src="//d3js.org/d3.v5.min.js"></script>
<script src="//d3js.org/topojson.v1.min.js"></script>
<script>

var width = 650,
    height = 650
    
var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height)

var canvas = d3.select("body").append("canvas")
    .attr("width", width)
    .attr("height", height)
	.style("display","none");
    
var context = canvas.node().getContext("2d")

Promise.all([
    d3.json('map/stl.json'),
    d3.csv('data/2010.csv')
]).then(vis)

function vis(data) {
    stl = data[0]
    d2010 = data[1]
        
    var projection = d3.geoTransverseMercator()
        .rotate([90 + 30 / 60, -35 - 50 / 60])
        .fitSize([width, height], stl)
    
    var path = d3.geoPath()
        .projection(projection);
        
    var tracts = stl.features
                    
    svg.append("g")
    .selectAll("path")
      .data(tracts)
    .enter().append("path")
      .attr("class", "tract")
      .attr("d", path)

    var num_tracts = tracts.length
    
    var stl_tract_ids = []
    for(var i=0; i<num_tracts; i++) {
        var tract_id = tracts[i].properties.TRACTCE10
        stl_tract_ids.push(tract_id)
    }
        
    // This will work if stl_tract_ids is sorted (close, but it's not)
    // function binarySearch(target, low, high) {
    //     var mid = low + Math.floor((high - low) / 2)
    //     var result = stl_tract_ids[mid]
    //     if (target == result) {
    //         return index
    //     }
    //     if (target > result) {
    //         return binarySearch(target, mid+1, high)
    //     }
    //     else {
    //         return binarySearch(target, low, mid-1)
    //     }
    // }
    
    var white_col = 'SE_T054_002',
        black_col = 'SE_T054_003'
        tract_id_col = 'Geo_TRACT'
        
    var white_by_tract = new Array(num_tracts)
    var black_by_tract = new Array(num_tracts)
    
    for (var i=0; i<num_tracts; i++) {
        var tract_data = d2010[i]
        var tract_id = parseInt(tract_data[tract_id_col])
        
        var num_white = parseInt(tract_data[white_col])
        var num_black = parseInt(tract_data[black_col])
        
        var tract_index = 0
        for (var j=0; j<num_tracts; j++) {
            if (tract_id == stl_tract_ids[j]) {
                tract_index = j
                break
            }
        }
        white_by_tract[tract_index] = num_white
        black_by_tract[tract_index] = num_black
    }
    
    function drawPolygon(coordinates, fill) {
        context.fillStyle = fill
    	context.beginPath();
    	coordinates.forEach( function(ring){
    		ring.forEach( function(coord, i){
    			var projected = projection( coord );
    			if (i == 0) {
                    context.moveTo(projected[0], projected[1])
                } else {
                    context.lineTo(projected[0], projected[1])
                }
    		})
    	})
    	context.closePath()
    	context.fill()    
    }
    
    for (var i=0; i<num_tracts; i++) {
        var r = Math.floor(i / 256),
            g = i % 256
        
        var coordinates = tracts[i].geometry.coordinates,
            fill = "rgb(" + r + "," + g + ",0)"
        
        drawPolygon(coordinates, fill)
    }
    
    var pixels = context.getImageData(0,0,width,height).data;

    for (var i=0; i<num_tracts; i++) {
        tract = tracts[i]
        white_pop = Math.round(white_by_tract[i] / 50)
        black_pop = Math.round(black_by_tract[i] / 50)

        var bounds = path.bounds(tract),
            x0 = bounds[0][0],
            y0 = bounds[0][1],
            w = bounds[1][0] - x0,
            h = bounds[1][1] - y0

        for (var j=0; j<white_pop; j++) {
            var tries = 1

            while (true) {
                var x = Math.round(x0 + Math.random()*w),
                    y = Math.round(y0 + Math.random()*h)
                
                var r = Math.floor(i / 256),
                    g = i % 256
                
            	var index = (x + y * width) * 4
                
                var actual_r = pixels[index],
                    actual_g = pixels[index+1]
                             
                var contains = actual_r == r && actual_g == g
                if (contains) {
                    svg.append("circle")
                        .attr("cx", x)
                        .attr("cy", y)
                        .attr("r", 1)
                        .attr("fill", "blue")
                        .attr("fill-opacity", .2)
                    break
                }

                tries++
            }
        }
        
        for (var j=0; j<black_pop; j++) {
            var tries = 1

            while (true) {
                var x = Math.round(x0 + Math.random()*w),
                    y = Math.round(y0 + Math.random()*h)
                
                var r = Math.floor(i / 256),
                    g = i % 256
                
            	var index = (x + y * width) * 4
                
                var actual_r = pixels[index],
                    actual_g = pixels[index+1]
                             
                var contains = actual_r == r && actual_g == g
                if (contains) {
                    svg.append("circle")
                        .attr("cx", x)
                        .attr("cy", y)
                        .attr("r", 1)
                        .attr("fill", "red")
                        .attr("fill-opacity", .2)
                    break
                }

                tries++
            }
        }
    }
}

</script>
